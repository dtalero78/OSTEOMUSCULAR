/**
 * Cliente del M√©dico - Telemedicina
 * Recibe y visualiza datos de pose del paciente en tiempo real
 */

class TelemedicineDoctor {
    constructor() {
        this.socket = io();
        this.canvas = null;
        this.ctx = null;

        this.sessionCode = null;
        this.isSessionActive = false;
        this.patientConnected = false;
        this.isExamRunning = false;

        // Datos del m√©dico
        this.doctorData = {
            name: '',
            specialty: 'traumatologia',
            sessionId: null
        };

        // Tipo de examen m√©dico
        this.currentExamType = 'completo';

        // Sistema de instrucciones guiadas m√©dicas
        this.instructionSystem = {
            currentStep: 0,
            isActive: false,
            audioEnabled: true,
            speechSynthesis: window.speechSynthesis
        };

        // Secuencias de examen m√©dico completas del an√°lisis original
        this.examSequences = {
            postura: [
                {
                    icon: 'üßç',
                    title: 'Posici√≥n Inicial',
                    text: 'Col√≥quese de pie, relajado, con los brazos a los costados. Mire hacia la c√°mara.',
                    duration: 5000,
                    audio: 'Col√≥quese de pie, relajado, con los brazos a los costados. Mire hacia la c√°mara.',
                    validation: 'checkBasicStance'
                },
                {
                    icon: 'üëÄ',
                    title: 'Vista Frontal',
                    text: 'Mantenga la cabeza erguida y mire directamente a la c√°mara. Respiraci√≥n normal.',
                    duration: 8000,
                    audio: 'Mantenga la cabeza erguida y mire directamente a la c√°mara. Respiraci√≥n normal.',
                    validation: 'checkFrontalView'
                },
                {
                    icon: 'üí™',
                    title: 'Brazos Naturales',
                    text: 'Deje los brazos caer naturalmente a los costados. No fuerce la posici√≥n.',
                    duration: 6000,
                    audio: 'Deje los brazos caer naturalmente a los costados. No fuerce la posici√≥n.',
                    validation: 'checkArmPosition'
                },
                {
                    icon: 'üì∏',
                    title: 'Captura Final',
                    text: 'Perfecto. Mantenga esta posici√≥n mientras capturamos los datos.',
                    duration: 10000,
                    audio: 'Perfecto. Mantenga esta posici√≥n mientras capturamos los datos.',
                    validation: 'checkFinalCapture'
                }
            ],
            rangos: [
                {
                    icon: 'üßç',
                    title: 'Posici√≥n Base',
                    text: 'Col√≥quese en posici√≥n inicial: de pie, brazos a los costados.',
                    duration: 4000,
                    audio: 'Col√≥quese en posici√≥n inicial: de pie, brazos a los costados.',
                    validation: 'checkBasicStance'
                },
                {
                    icon: 'üôã‚Äç‚ôÄÔ∏è',
                    title: 'Elevar Brazos',
                    text: 'Levante lentamente ambos brazos hacia los lados hasta la altura de los hombros.',
                    duration: 8000,
                    audio: 'Levante lentamente ambos brazos hacia los lados hasta la altura de los hombros.',
                    validation: 'checkArmRaise'
                },
                {
                    icon: 'üôå',
                    title: 'Brazos Arriba',
                    text: 'Ahora levante los brazos completamente por encima de la cabeza.',
                    duration: 8000,
                    audio: 'Ahora levante los brazos completamente por encima de la cabeza.',
                    validation: 'checkArmsUp'
                },
                {
                    icon: 'üîÑ',
                    title: 'Rotaci√≥n de Hombros',
                    text: 'Baje los brazos y haga c√≠rculos lentos con los hombros hacia atr√°s.',
                    duration: 10000,
                    audio: 'Baje los brazos y haga c√≠rculos lentos con los hombros hacia atr√°s.',
                    validation: 'checkShoulderRotation'
                },
                {
                    icon: 'ü¶µ',
                    title: 'Flexi√≥n de Cadera',
                    text: 'Levante una pierna, flexionando la rodilla a 90 grados. Mantenga el equilibrio.',
                    duration: 8000,
                    audio: 'Levante una pierna, flexionando la rodilla a 90 grados. Mantenga el equilibrio.',
                    validation: 'checkHipFlexion'
                }
            ],
            simetria: [
                {
                    icon: 'üßç',
                    title: 'Postura Sim√©trica',
                    text: 'Col√≥quese con los pies separados al ancho de los hombros, peso distribuido igual.',
                    duration: 6000,
                    audio: 'Col√≥quese con los pies separados al ancho de los hombros, peso distribuido igual.',
                    validation: 'checkSymmetricStance'
                },
                {
                    icon: '‚öñÔ∏è',
                    title: 'Verificaci√≥n de Balance',
                    text: 'Mantenga esta posici√≥n. Vamos a analizar la simetr√≠a de sus hombros y caderas.',
                    duration: 10000,
                    audio: 'Mantenga esta posici√≥n. Vamos a analizar la simetr√≠a de sus hombros y caderas.',
                    validation: 'checkBalance'
                }
            ],
            completo: [
                {
                    icon: 'üè•',
                    title: 'Examen Completo',
                    text: 'Realizaremos un an√°lisis integral. Siga todas las instrucciones cuidadosamente.',
                    duration: 5000,
                    audio: 'Realizaremos un an√°lisis integral. Siga todas las instrucciones cuidadosamente.',
                    validation: 'checkReadiness'
                }
            ]
        };

        // Datos del paciente conectado
        this.patientData = null;

        // M√©tricas recibidas del paciente
        this.currentMetrics = {
            posture: {},
            joints: {},
            symmetry: {}
        };

        // Estad√≠sticas de transmisi√≥n
        this.transmissionStats = {
            fps: 0,
            latency: 0,
            frameCount: 0,
            lastFrameTime: 0,
            qualityScore: 'Esperando...'
        };

        // Capturas realizadas
        this.snapshots = [];

        // Landmarks recibidos
        this.receivedLandmarks = null;

        // WebRTC configuration
        this.peerConnection = null;
        this.remoteVideo = null;
        this.iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        this.initializeInterface();
    }

    async initializeInterface() {
        console.log('üë®‚Äç‚öïÔ∏è Inicializando interfaz del m√©dico...');

        try {
            // Inicializar elementos DOM
            this.initializeDOMElements();

            // Configurar event listeners
            this.setupEventListeners();

            // Configurar Socket.io events
            this.setupSocketEvents();

            console.log('‚úÖ Interfaz del m√©dico lista');

        } catch (error) {
            console.error('‚ùå Error inicializando interfaz:', error);
        }
    }

    initializeDOMElements() {
        // Elementos de configuraci√≥n del m√©dico
        this.doctorNameInput = document.getElementById('doctorName');
        this.doctorSpecialtySelect = document.getElementById('doctorSpecialty');
        this.examTypeSelect = document.getElementById('examType');
        this.createSessionBtn = document.getElementById('createSessionBtn');

        // Elementos de sesi√≥n
        this.sessionCodeContainer = document.getElementById('sessionCodeContainer');
        this.sessionCodeDisplay = document.getElementById('sessionCodeDisplay');
        this.connectionStatus = document.getElementById('connectionStatus');

        // Elementos de informaci√≥n del paciente
        this.patientInfo = document.getElementById('patientInfo');
        this.patientName = document.getElementById('patientName');
        this.patientAge = document.getElementById('patientAge');
        this.connectionTime = document.getElementById('connectionTime');

        // Elementos de video
        this.patientVideoContainer = document.getElementById('patientVideoContainer');
        this.remoteVideo = document.getElementById('remoteVideo');
        this.videoPlaceholder = document.getElementById('videoPlaceholder');
        this.videoInfo = document.getElementById('videoInfo');
        this.canvas = document.getElementById('patientCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.noPatientMessage = document.getElementById('noPatientMessage');

        // Controles de examen
        this.startExamBtn = document.getElementById('startExamBtn');
        this.startGuidedBtn = document.getElementById('startGuidedBtn');
        this.stopExamBtn = document.getElementById('stopExamBtn');
        this.countdownBtn = document.getElementById('countdownBtn');

        // Instrucciones
        this.customInstructionInput = document.getElementById('customInstruction');
        this.sendInstructionBtn = document.getElementById('sendInstructionBtn');

        // M√©tricas
        this.metricElements = {
            cervicalAlign: document.getElementById('cervicalAlign'),
            pelvicTilt: document.getElementById('pelvicTilt'),
            lateralDev: document.getElementById('lateralDev'),
            rightShoulder: document.getElementById('rightShoulder'),
            leftShoulder: document.getElementById('leftShoulder'),
            rightHip: document.getElementById('rightHip'),
            leftHip: document.getElementById('leftHip'),
            shoulderSymmetry: document.getElementById('shoulderSymmetry'),
            hipSymmetry: document.getElementById('hipSymmetry'),
            overallBalance: document.getElementById('overallBalance')
        };

        // Otros elementos
        this.captureBtn = document.getElementById('captureBtn');
        this.snapshotsList = document.getElementById('snapshotsList');
        this.transmissionStatsEl = document.getElementById('transmissionStats');
        this.doctorNotes = document.getElementById('doctorNotes');
        this.generateReportBtn = document.getElementById('generateReportBtn');
        this.endSessionBtn = document.getElementById('endSessionBtn');
    }

    setupEventListeners() {
        // Crear sesi√≥n
        this.createSessionBtn.addEventListener('click', () => this.createSession());

        // Controles de examen
        this.startExamBtn.addEventListener('click', () => this.startExam());
        this.startGuidedBtn.addEventListener('click', () => this.startGuidedSequence());
        this.stopExamBtn.addEventListener('click', () => this.stopExam());
        this.countdownBtn.addEventListener('click', () => this.startCountdown());

        // Selecci√≥n de tipo de examen
        this.examTypeSelect.addEventListener('change', (e) => {
            this.currentExamType = e.target.value;
            console.log(`üîç Tipo de examen cambiado a: ${this.currentExamType}`);
        });

        // Instrucciones
        this.sendInstructionBtn.addEventListener('click', () => this.sendCustomInstruction());

        this.customInstructionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.sendCustomInstruction();
        });

        // Instrucciones r√°pidas
        document.querySelectorAll('.quick-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const instruction = btn.dataset.instruction;
                this.sendInstruction('instruction', {
                    title: 'Instrucci√≥n',
                    text: instruction
                });
            });
        });

        // Captura
        this.captureBtn.addEventListener('click', () => this.captureSnapshot());

        // Acciones finales
        this.generateReportBtn.addEventListener('click', () => this.generateReport());
        this.endSessionBtn.addEventListener('click', () => this.endSession());
    }

    setupSocketEvents() {
        // Conexi√≥n establecida
        this.socket.on('connect', () => {
            console.log('üîå M√©dico conectado al servidor');
        });

        // Sesi√≥n creada
        this.socket.on('session-created', ({ sessionCode, message }) => {
            console.log('‚úÖ Sesi√≥n creada:', sessionCode);

            this.sessionCode = sessionCode;
            this.isSessionActive = true;

            this.sessionCodeDisplay.textContent = sessionCode;
            this.sessionCodeContainer.classList.remove('hidden');
            this.updateConnectionStatus('üü° Sesi√≥n creada - Esperando paciente', 'waiting');

            // Mostrar √°rea de video con mensaje de espera
            this.patientVideoContainer.classList.remove('hidden');
            this.noPatientMessage.innerHTML = '<h3>üë§ Esperando conexi√≥n del paciente</h3>';
            this.noPatientMessage.style.display = 'flex';

            // Habilitar algunos controles
            this.createSessionBtn.disabled = true;
        });

        // Paciente conectado
        this.socket.on('patient-connected', ({ sessionCode, patientData, message }) => {
            console.log('üë§ Paciente conectado:', patientData);

            this.patientData = patientData;
            this.patientConnected = true;

            // Actualizar interfaz
            this.updateConnectionStatus('üü¢ Paciente conectado', 'connected');
            this.showPatientInfo();
            this.enableExamControls();

            // Configurar canvas para video
            this.setupCanvas();
        });

        // Datos de pose recibidos
        this.socket.on('receive-pose-data', ({ landmarks, metrics, timestamp }) => {
            console.log('üì• Datos de pose recibidos:', {
                landmarksCount: landmarks?.length || 0,
                hasMetrics: !!metrics,
                timestamp: timestamp
            });
            this.handlePoseData(landmarks, metrics, timestamp);
        });

        // Paciente desconectado
        this.socket.on('patient-disconnected', ({ message }) => {
            console.log('üë§ Paciente desconectado:', message);

            this.patientConnected = false;
            this.isExamRunning = false;

            this.updateConnectionStatus('üü° Paciente desconectado', 'waiting');
            this.hidePatientInfo();
            this.disableExamControls();
            this.clearCanvas();
        });

        // Snapshot capturado
        this.socket.on('snapshot-captured', ({ snapshotData, timestamp }) => {
            console.log('üì∏ Confirmaci√≥n de snapshot');
        });

        // WebRTC signaling - Offer del paciente
        this.socket.on('webrtc-offer', async ({ offer }) => {
            console.log('üìπ WebRTC Offer recibido del paciente');
            await this.handleWebRTCOffer(offer);
        });

        // WebRTC ICE candidates
        this.socket.on('webrtc-ice-candidate', async ({ candidate }) => {
            console.log('üßä ICE candidate recibido');
            if (this.peerConnection && candidate) {
                await this.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            }
        });

        // Desconexi√≥n
        this.socket.on('disconnect', () => {
            console.log('üîå Desconectado del servidor');
            this.updateConnectionStatus('üî¥ Desconectado del servidor', 'error');
            this.resetSession();
        });
    }

    async handleWebRTCOffer(offer) {
        try {
            console.log('üîó Configurando WebRTC en lado del m√©dico...');
            console.log('üìã Offer recibido:', offer?.type, offer?.sdp?.substring(0, 50) + '...');

            if (!this.sessionCode) {
                console.error('‚ùå M√©dico no tiene sessionCode activo');
                return;
            }

            if (!this.patientConnected) {
                console.error('‚ùå No hay paciente conectado');
                return;
            }

            console.log('‚úÖ M√©dico listo para aceptar WebRTC con sesi√≥n:', this.sessionCode);

            // Crear peer connection
            this.peerConnection = new RTCPeerConnection(this.iceServers);

            // Manejar tracks entrantes (video del paciente)
            this.peerConnection.ontrack = (event) => {
                console.log('üìπ Stream recibido:', event.streams[0]);
                this.remoteVideo.srcObject = event.streams[0];

                // Mostrar video y ocultar placeholder
                if (this.videoPlaceholder) {
                    this.videoPlaceholder.style.display = 'none';
                    this.videoPlaceholder.style.visibility = 'hidden';
                }

                // Asegurar que el video sea visible
                this.remoteVideo.style.display = 'block';
                this.remoteVideo.style.visibility = 'visible';
                this.remoteVideo.style.opacity = '1';

                // Actualizar info del video
                this.remoteVideo.onloadedmetadata = () => {
                    const width = this.remoteVideo.videoWidth;
                    const height = this.remoteVideo.videoHeight;
                    this.videoInfo.textContent = `Resoluci√≥n: ${width}x${height} | En vivo`;
                    console.log('‚úÖ Video del paciente mostr√°ndose:', width, 'x', height);
                };

                // Play autom√°tico si est√° pausado
                this.remoteVideo.play().catch(err => {
                    console.log('‚ö†Ô∏è Autoplay bloqueado, requiere interacci√≥n del usuario:', err);
                });
            };

            // Manejar ICE candidates
            this.peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('üßä Enviando ICE candidate al paciente');
                    this.socket.emit('webrtc-ice-candidate', {
                        sessionCode: this.sessionCode,
                        candidate: event.candidate
                    });
                }
            };

            // Manejar estado de conexi√≥n
            this.peerConnection.onconnectionstatechange = () => {
                console.log('üîó Estado WebRTC:', this.peerConnection.connectionState);
                if (this.peerConnection.connectionState === 'connected') {
                    console.log('‚úÖ Video streaming conectado');
                } else if (this.peerConnection.connectionState === 'failed') {
                    console.error('‚ùå Conexi√≥n WebRTC fall√≥');
                    if (this.videoPlaceholder) {
                        this.videoPlaceholder.innerHTML = '<div style="text-align: center; color: #f44336;">‚ùå Error de conexi√≥n<br><small>Intentando reconectar...</small></div>';
                        this.videoPlaceholder.style.display = 'flex';
                    }
                }
            };

            // Establecer remote description (offer del paciente)
            await this.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

            // Crear answer
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);

            // Enviar answer al paciente
            console.log('üì§ Enviando WebRTC answer al paciente');
            console.log('üìã Answer SDP:', answer.type, answer.sdp?.substring(0, 50) + '...');
            this.socket.emit('webrtc-answer', {
                sessionCode: this.sessionCode,
                answer: answer
            });
            console.log('‚úÖ Answer enviado con sessionCode:', this.sessionCode);

        } catch (error) {
            console.error('‚ùå Error configurando WebRTC:', error);
        }
    }

    createSession() {
        const doctorName = this.doctorNameInput.value.trim();
        const specialty = this.doctorSpecialtySelect.value;

        if (!doctorName) {
            alert('Por favor ingrese su nombre');
            return;
        }

        this.doctorData = {
            name: doctorName,
            specialty: specialty,
            sessionId: Date.now()
        };

        console.log('üöÄ Creando sesi√≥n m√©dica...');

        this.socket.emit('doctor-register', this.doctorData);
    }

    startExam() {
        if (!this.patientConnected) return;

        console.log('‚ñ∂Ô∏è Iniciando examen...');
        this.isExamRunning = true;

        // Enviar comando al paciente
        this.sendCommand('start_exam', {
            timestamp: Date.now(),
            examType: 'completo'
        });

        // Actualizar controles
        this.startExamBtn.disabled = true;
        this.stopExamBtn.disabled = false;
        this.captureBtn.disabled = false;

        this.updateConnectionStatus('üî¨ Examen en progreso', 'examining');
    }

    stopExam() {
        console.log('‚èπÔ∏è Deteniendo examen...');
        this.isExamRunning = false;

        // Enviar comando al paciente
        this.sendCommand('stop_exam', {
            timestamp: Date.now()
        });

        // Actualizar controles
        this.startExamBtn.disabled = false;
        this.stopExamBtn.disabled = true;
        this.captureBtn.disabled = true;

        this.updateConnectionStatus('üü¢ Paciente conectado - Examen detenido', 'connected');
    }

    startCountdown(seconds = 5) {
        if (!this.patientConnected) return;

        console.log(`‚è∞ Iniciando cuenta regresiva de ${seconds} segundos`);

        this.sendCommand('countdown', {
            seconds: seconds,
            message: `Iniciando en ${seconds} segundos`
        });
    }

    startGuidedSequence() {
        if (!this.patientConnected) return;

        console.log(`üéØ Iniciando secuencia guiada de tipo: ${this.currentExamType}`);

        // Resetear sistema de instrucciones
        this.instructionSystem.currentStep = 0;
        this.instructionSystem.isActive = true;

        const sequence = this.examSequences[this.currentExamType] || this.examSequences.completo;

        // Enviar primera instrucci√≥n al paciente
        this.sendCommand('start_guided_sequence', {
            examType: this.currentExamType,
            totalSteps: sequence.length,
            currentStep: 0,
            instruction: sequence[0]
        });

        // Actualizar estado
        this.isExamRunning = true;
        this.startExamBtn.disabled = true;
        this.startGuidedBtn.disabled = true;
        this.stopExamBtn.disabled = false;
        this.captureBtn.disabled = false;

        this.updateConnectionStatus(`üéØ Secuencia guiada ${this.currentExamType} iniciada`, 'examining');

        // Programar siguiente paso
        this.scheduleNextInstruction(sequence[0].duration);
    }

    scheduleNextInstruction(duration) {
        if (!this.instructionSystem.isActive) return;

        this.instructionTimeout = setTimeout(() => {
            this.nextGuidedStep();
        }, duration);
    }

    nextGuidedStep() {
        if (!this.instructionSystem.isActive) return;

        const sequence = this.examSequences[this.currentExamType] || this.examSequences.completo;
        this.instructionSystem.currentStep++;

        if (this.instructionSystem.currentStep >= sequence.length) {
            this.completeGuidedSequence();
        } else {
            const currentInstruction = sequence[this.instructionSystem.currentStep];

            // Enviar siguiente instrucci√≥n
            this.sendCommand('next_guided_step', {
                examType: this.currentExamType,
                totalSteps: sequence.length,
                currentStep: this.instructionSystem.currentStep,
                instruction: currentInstruction
            });

            // Programar siguiente paso
            this.scheduleNextInstruction(currentInstruction.duration);
        }
    }

    completeGuidedSequence() {
        console.log('‚úÖ Secuencia guiada completada');

        this.instructionSystem.isActive = false;

        if (this.instructionTimeout) {
            clearTimeout(this.instructionTimeout);
        }

        // Notificar al paciente
        this.sendCommand('complete_guided_sequence', {
            examType: this.currentExamType,
            message: 'Secuencia completada - Excelente trabajo'
        });

        this.updateConnectionStatus('‚úÖ Secuencia guiada completada - Analizando datos', 'connected');

        // Capturar autom√°ticamente al completar
        setTimeout(() => {
            this.captureSnapshot();
        }, 2000);
    }

    sendCustomInstruction() {
        const instruction = this.customInstructionInput.value.trim();
        if (!instruction) return;

        this.sendInstruction('instruction', {
            title: 'Instrucci√≥n Personalizada',
            text: instruction
        });

        this.customInstructionInput.value = '';
    }

    sendInstruction(type, data) {
        if (!this.patientConnected) return;

        this.sendCommand(type, data);
        console.log('üìã Instrucci√≥n enviada:', data.text);
    }

    sendCommand(command, data) {
        if (!this.sessionCode) return;

        this.socket.emit('doctor-command', {
            sessionCode: this.sessionCode,
            command: command,
            data: data
        });
    }

    captureSnapshot() {
        if (!this.patientConnected || !this.receivedLandmarks) return;

        console.log('üì∏ Capturando snapshot m√©dico...');

        const snapshot = {
            id: Date.now(),
            timestamp: new Date().toISOString(),
            patientData: this.patientData,
            landmarks: this.receivedLandmarks,
            metrics: { ...this.currentMetrics },
            notes: this.doctorNotes.value || '',
            doctorData: this.doctorData
        };

        this.snapshots.push(snapshot);

        // Enviar comando de captura al paciente
        this.sendCommand('capture_snapshot', {
            snapshotId: snapshot.id,
            timestamp: snapshot.timestamp
        });

        // Actualizar lista de snapshots
        this.updateSnapshotsList();
    }

    handlePoseData(landmarks, metrics, timestamp) {
        if (!this.patientConnected) return;

        // Guardar datos recibidos
        this.receivedLandmarks = landmarks;
        this.currentMetrics = metrics;

        // Actualizar estad√≠sticas de transmisi√≥n
        this.updateTransmissionStats(timestamp);

        // Dibujar pose en canvas
        this.drawPoseOnCanvas(landmarks);

        // Actualizar m√©tricas en interfaz
        this.updateMetricsDisplay();
    }

    setupCanvas() {
        // Configurar canvas para mostrar pose del paciente
        this.canvas.width = 600;
        this.canvas.height = 400;

        // Ajustar canvas al contenedor de an√°lisis
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.objectFit = 'contain';

        this.patientVideoContainer.classList.remove('hidden');

        // Mostrar mensaje de espera hasta que lleguen datos
        this.noPatientMessage.innerHTML = '<h3>‚è≥ Esperando stream de datos del paciente...</h3>';
        this.noPatientMessage.style.display = 'flex';

        console.log('üìä Canvas configurado para an√°lisis de esqueleto:', this.canvas.width, 'x', this.canvas.height);
    }

    drawPoseOnCanvas(landmarks) {
        if (!landmarks || landmarks.length === 0) return;

        // Ocultar mensaje de espera cuando llegan datos
        if (this.noPatientMessage.style.display !== 'none') {
            this.noPatientMessage.style.display = 'none';
        }

        // Limpiar canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Configurar estilos de dibujo
        const pointRadius = 6;
        const lineWidth = 3;

        // Definir conexiones del esqueleto
        const connections = [
            [11, 12], // hombros
            [11, 13], [13, 15], // brazo izquierdo
            [12, 14], [14, 16], // brazo derecho
            [11, 23], [12, 24], // torso
            [23, 24], // caderas
            [23, 25], [25, 27], // pierna izquierda
            [24, 26], [26, 28]  // pierna derecha
        ];

        // Dibujar conexiones
        this.ctx.strokeStyle = '#00ff00';
        this.ctx.lineWidth = lineWidth;
        this.ctx.beginPath();

        connections.forEach(([start, end]) => {
            const startPoint = landmarks[start];
            const endPoint = landmarks[end];

            if (startPoint && endPoint) {
                this.ctx.moveTo(
                    startPoint.x * this.canvas.width,
                    startPoint.y * this.canvas.height
                );
                this.ctx.lineTo(
                    endPoint.x * this.canvas.width,
                    endPoint.y * this.canvas.height
                );
            }
        });

        this.ctx.stroke();

        // Dibujar puntos importantes
        const importantLandmarks = [0, 11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];

        landmarks.forEach((landmark, index) => {
            const x = landmark.x * this.canvas.width;
            const y = landmark.y * this.canvas.height;

            // Color seg√∫n importancia
            let color = '#00ff00';
            if (importantLandmarks.includes(index)) {
                color = '#ff0000';
            }

            this.ctx.fillStyle = color;
            this.ctx.beginPath();
            this.ctx.arc(x, y, pointRadius, 0, 2 * Math.PI);
            this.ctx.fill();

            // Contorno blanco
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
        });

        // Dibujar informaci√≥n de an√°lisis m√©dico
        this.ctx.fillStyle = '#00ff00';
        this.ctx.font = 'bold 14px Arial';
        this.ctx.fillText(`ü¶¥ Landmarks: ${landmarks.length}`, 10, 25);

        this.ctx.fillStyle = '#ffff00';
        this.ctx.fillText(`üìä FPS: ${this.transmissionStats.fps}`, 10, 45);
        this.ctx.fillText(`‚è±Ô∏è Latencia: ${this.transmissionStats.latency}ms`, 10, 65);

        // Mostrar calidad de an√°lisis
        const qualityColor = this.transmissionStats.qualityScore === 'Excelente' ? '#00ff00' :
                           this.transmissionStats.qualityScore === 'Buena' ? '#ffff00' : '#ff6600';
        this.ctx.fillStyle = qualityColor;
        this.ctx.fillText(`üéØ Calidad: ${this.transmissionStats.qualityScore}`, 10, 85);

        // Indicador de an√°lisis m√©dico activo
        if (this.isExamRunning) {
            this.ctx.fillStyle = '#ff0080';
            this.ctx.font = 'bold 12px Arial';
            this.ctx.fillText(`ü©∫ AN√ÅLISIS M√âDICO ACTIVO`, 10, 110);
        }
    }

    updateMetricsDisplay() {
        const metrics = this.currentMetrics;

        // Actualizar valores
        this.metricElements.cervicalAlign.textContent = `${metrics.posture.cervicalAlignment?.toFixed(1) || '--'}¬∞`;
        this.metricElements.pelvicTilt.textContent = `${metrics.posture.pelvicTilt?.toFixed(1) || '--'}¬∞`;
        this.metricElements.lateralDev.textContent = `${metrics.posture.lateralDeviation?.toFixed(0) || '--'}mm`;

        this.metricElements.rightShoulder.textContent = `${metrics.joints.rightShoulderAngle?.toFixed(0) || '--'}¬∞`;
        this.metricElements.leftShoulder.textContent = `${metrics.joints.leftShoulderAngle?.toFixed(0) || '--'}¬∞`;
        this.metricElements.rightHip.textContent = `${metrics.joints.rightHipAngle?.toFixed(0) || '--'}¬∞`;
        this.metricElements.leftHip.textContent = `${metrics.joints.leftHipAngle?.toFixed(0) || '--'}¬∞`;

        this.metricElements.shoulderSymmetry.textContent = `${metrics.symmetry.shoulderSymmetry?.toFixed(0) || '--'}%`;
        this.metricElements.hipSymmetry.textContent = `${metrics.symmetry.hipSymmetry?.toFixed(0) || '--'}%`;
        this.metricElements.overallBalance.textContent = `${metrics.symmetry.overallBalance?.toFixed(0) || '--'}%`;

        // Aplicar colores seg√∫n rangos m√©dicos
        this.applyMetricColors();
    }

    applyMetricColors() {
        const metrics = this.currentMetrics;

        // Colores para alineaci√≥n cervical
        const cervicalValue = metrics.posture.cervicalAlignment || 0;
        this.metricElements.cervicalAlign.className = 'metric-value ' +
            (cervicalValue < 10 ? 'metric-normal' : cervicalValue < 15 ? 'metric-warning' : 'metric-alert');

        // Colores para inclinaci√≥n p√©lvica
        const pelvicValue = metrics.posture.pelvicTilt || 0;
        this.metricElements.pelvicTilt.className = 'metric-value ' +
            (pelvicValue < 5 ? 'metric-normal' : pelvicValue < 10 ? 'metric-warning' : 'metric-alert');

        // Colores para simetr√≠a
        const shoulderSymmetry = metrics.symmetry.shoulderSymmetry || 0;
        this.metricElements.shoulderSymmetry.className = 'metric-value ' +
            (shoulderSymmetry > 90 ? 'metric-normal' : shoulderSymmetry > 85 ? 'metric-warning' : 'metric-alert');

        const overallBalance = metrics.symmetry.overallBalance || 0;
        this.metricElements.overallBalance.className = 'metric-value ' +
            (overallBalance > 80 ? 'metric-normal' : overallBalance > 70 ? 'metric-warning' : 'metric-alert');
    }

    updateTransmissionStats(timestamp) {
        const now = Date.now();

        // Calcular FPS
        if (this.transmissionStats.lastFrameTime > 0) {
            const deltaTime = now - this.transmissionStats.lastFrameTime;
            this.transmissionStats.fps = Math.round(1000 / deltaTime);
        }

        // Calcular latencia
        this.transmissionStats.latency = now - timestamp;
        this.transmissionStats.frameCount++;
        this.transmissionStats.lastFrameTime = now;

        // Determinar calidad
        if (this.transmissionStats.fps > 25 && this.transmissionStats.latency < 100) {
            this.transmissionStats.qualityScore = 'Excelente';
        } else if (this.transmissionStats.fps > 15 && this.transmissionStats.latency < 200) {
            this.transmissionStats.qualityScore = 'Buena';
        } else if (this.transmissionStats.fps > 10) {
            this.transmissionStats.qualityScore = 'Regular';
        } else {
            this.transmissionStats.qualityScore = 'Pobre';
        }

        // Actualizar display
        this.transmissionStatsEl.innerHTML = `
            FPS: ${this.transmissionStats.fps}<br>
            Latencia: ${this.transmissionStats.latency}ms<br>
            Frames: ${this.transmissionStats.frameCount}<br>
            Calidad: ${this.transmissionStats.qualityScore}
        `;
    }

    updateSnapshotsList() {
        this.snapshotsList.innerHTML = '';

        this.snapshots.forEach((snapshot, index) => {
            const item = document.createElement('div');
            item.className = 'snapshot-item';
            item.innerHTML = `
                <strong>Captura ${index + 1}</strong><br>
                ${new Date(snapshot.timestamp).toLocaleTimeString()}<br>
                <small>Cervical: ${snapshot.metrics.posture.cervicalAlignment?.toFixed(1)}¬∞</small>
            `;
            this.snapshotsList.appendChild(item);
        });
    }

    generateReport() {
        console.log('üìÑ Generando informe m√©dico...');

        const report = {
            sessionInfo: {
                sessionCode: this.sessionCode,
                date: new Date().toLocaleDateString('es-ES'),
                time: new Date().toLocaleTimeString('es-ES'),
                duration: 'Calculando...'
            },
            doctorInfo: this.doctorData,
            patientInfo: this.patientData,
            currentMetrics: this.currentMetrics,
            snapshots: this.snapshots,
            doctorNotes: this.doctorNotes.value || '',
            recommendations: this.generateRecommendations()
        };

        // Crear y descargar archivo JSON
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `informe_telemedicina_${this.patientData.name}_${Date.now()}.json`;
        a.click();

        console.log('‚úÖ Informe generado');
    }

    generateRecommendations() {
        const recommendations = [];
        const metrics = this.currentMetrics;

        // Recomendaciones basadas en alineaci√≥n cervical
        if (metrics.posture.cervicalAlignment > 15) {
            recommendations.push('üî∏ Considerar evaluaci√≥n de postura cervical - desviaci√≥n significativa detectada');
            recommendations.push('üìã Recomendaciones: Ejercicios de fortalecimiento cervical y correcci√≥n postural');
        } else if (metrics.posture.cervicalAlignment > 10) {
            recommendations.push('‚ö†Ô∏è Alineaci√≥n cervical en l√≠mite superior - monitorear evoluci√≥n');
        }

        // Recomendaciones basadas en inclinaci√≥n p√©lvica
        if (metrics.posture.pelvicTilt > 5) {
            recommendations.push('üî∏ Revisar alineaci√≥n p√©lvica - inclinaci√≥n fuera del rango normal');
            recommendations.push('üìã Recomendaciones: Ejercicios de estabilizaci√≥n p√©lvica y fortalecimiento del core');
        }

        // Recomendaciones basadas en desviaci√≥n lateral
        if (metrics.posture.lateralDeviation > 30) {
            recommendations.push('üî∏ Desviaci√≥n lateral significativa - requiere atenci√≥n m√©dica');
            recommendations.push('üìã Recomendaciones: Evaluaci√≥n ortop√©dica para descartar escoliosis o desequilibrios musculares');
        } else if (metrics.posture.lateralDeviation > 20) {
            recommendations.push('‚ö†Ô∏è Desviaci√≥n lateral moderada - ejercicios de correcci√≥n recomendados');
        }

        // Recomendaciones basadas en simetr√≠a
        if (metrics.symmetry.shoulderSymmetry < 85) {
            recommendations.push('üî∏ Asimetr√≠a en hombros detectada - considerar evaluaci√≥n ortop√©dica');
            recommendations.push('üìã Recomendaciones: Ejercicios de equilibrio muscular y estiramiento espec√≠fico');
        }

        if (metrics.symmetry.hipSymmetry < 85) {
            recommendations.push('üî∏ Asimetr√≠a en caderas detectada - evaluaci√≥n de longitud de miembros');
            recommendations.push('üìã Recomendaciones: An√°lisis biomec√°nico y correcci√≥n de desequilibrios');
        }

        if (metrics.symmetry.overallBalance < 80) {
            recommendations.push('üî∏ Desequilibrio postural general - recomendable fisioterapia postural');
            recommendations.push('üìã Recomendaciones: Programa integral de reeducaci√≥n postural');
        } else if (metrics.symmetry.overallBalance < 90) {
            recommendations.push('‚ö†Ô∏è Balance postural mejorable - ejercicios de propriocepci√≥n recomendados');
        }

        // Recomendaciones basadas en √°ngulos articulares
        if (metrics.joints.rightShoulderAngle < 160 || metrics.joints.leftShoulderAngle < 160) {
            recommendations.push('üî∏ Limitaci√≥n en rango articular de hombros - evaluaci√≥n de movilidad');
            recommendations.push('üìã Recomendaciones: Ejercicios de movilizaci√≥n y estiramiento espec√≠fico');
        }

        if (metrics.joints.rightHipAngle < 170 || metrics.joints.leftHipAngle < 170) {
            recommendations.push('üî∏ Posible limitaci√≥n en extensi√≥n de cadera - evaluaci√≥n funcional');
            recommendations.push('üìã Recomendaciones: Ejercicios de flexibilidad y fortalecimiento de caderas');
        }

        // Recomendaciones espec√≠ficas por tipo de examen
        if (this.currentExamType === 'rangos') {
            recommendations.push('üìã Evaluaci√≥n de rangos de movimiento: Considerar an√°lisis biomec√°nico completo');
        } else if (this.currentExamType === 'simetria') {
            recommendations.push('üìã An√°lisis de simetr√≠a: Monitorear evoluci√≥n y considerar correcci√≥n postural');
        }

        // Si no hay problemas detectados
        if (recommendations.length === 0) {
            recommendations.push('‚úÖ Par√°metros posturales dentro de rangos normales');
            recommendations.push('üìã Recomendaciones: Mantener actividad f√≠sica regular y controles preventivos');
        }

        return recommendations;
    }

    showPatientInfo() {
        this.patientName.textContent = this.patientData.name;
        this.patientAge.textContent = this.patientData.age;
        this.connectionTime.textContent = new Date().toLocaleTimeString();
        this.patientInfo.classList.remove('hidden');
    }

    hidePatientInfo() {
        this.patientInfo.classList.add('hidden');
    }

    enableExamControls() {
        this.startExamBtn.disabled = false;
        this.startGuidedBtn.disabled = false;
        this.countdownBtn.disabled = false;
        this.sendInstructionBtn.disabled = false;
        this.generateReportBtn.disabled = false;
        this.endSessionBtn.disabled = false;
    }

    disableExamControls() {
        this.startExamBtn.disabled = true;
        this.stopExamBtn.disabled = true;
        this.countdownBtn.disabled = true;
        this.captureBtn.disabled = true;
        this.sendInstructionBtn.disabled = true;
    }

    clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.patientVideoContainer.classList.add('hidden');

        // Solo mostrar mensaje si hay sesi√≥n activa
        if (this.isSessionActive) {
            this.noPatientMessage.innerHTML = '<h3>üë§ Esperando conexi√≥n del paciente</h3>';
            this.noPatientMessage.style.display = 'flex';
        } else {
            this.noPatientMessage.style.display = 'none';
        }
    }

    endSession() {
        console.log('üîö Finalizando sesi√≥n...');

        this.socket.disconnect();
        this.resetSession();

        alert('‚úÖ Sesi√≥n finalizada. Puede cerrar la ventana.');
    }

    resetSession() {
        this.sessionCode = null;
        this.isSessionActive = false;
        this.patientConnected = false;
        this.isExamRunning = false;

        this.sessionCodeContainer.classList.add('hidden');
        this.hidePatientInfo();
        this.clearCanvas();
        this.disableExamControls();

        this.createSessionBtn.disabled = false;
        this.updateConnectionStatus('üî¥ Sesi√≥n finalizada', 'error');
    }

    updateConnectionStatus(message, type) {
        this.connectionStatus.textContent = message;
        this.connectionStatus.className = `connection-status status-${type}`;
    }
}

// Inicializar cuando se carga la p√°gina
document.addEventListener('DOMContentLoaded', () => {
    console.log('üë®‚Äç‚öïÔ∏è Iniciando interfaz del m√©dico...');
    window.telemedicineDoctor = new TelemedicineDoctor();
});